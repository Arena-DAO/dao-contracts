/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.11.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { CurveType, Uint128, HatcherAllowlistConfigType, Uint64, Decimal, InstantiateMsg, HatcherAllowlistEntryMsg, HatcherAllowlistConfigMsg, MinMax, CommonsPhaseConfig, ClosedConfig, HatchConfig, OpenConfig, ReserveToken, SupplyToken, NewDenomMetadata, DenomUnit, ExecuteMsg, UpdatePhaseConfigMsg, Action, Expiration, Timestamp, QueryMsg, QuoteResponse, CurveInfoResponse, DenomResponse, Addr, DonationsResponse, CommonsPhase, DumpStateResponse, CommonsPhaseConfigResponse, NullableAddr, HatcherAllowlistResponse, HatcherAllowlistEntry, HatcherAllowlistConfig, HatchersResponse, Boolean, NullableUint128, OwnershipForString, String } from "./CwAbc.types";
export interface CwAbcReadOnlyInterface {
  contractAddress: string;
  curveInfo: () => Promise<CurveInfoResponse>;
  curveType: () => Promise<CurveType>;
  denom: () => Promise<DenomResponse>;
  donations: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<DonationsResponse>;
  isPaused: () => Promise<Boolean>;
  fundingPoolForwarding: () => Promise<NullableAddr>;
  hatchers: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<HatchersResponse>;
  hatcher: ({
    addr
  }: {
    addr: string;
  }) => Promise<Uint128>;
  hatcherAllowlist: ({
    configType,
    limit,
    startAfter
  }: {
    configType?: HatcherAllowlistConfigType;
    limit?: number;
    startAfter?: string;
  }) => Promise<HatcherAllowlistResponse>;
  maxSupply: () => Promise<NullableUint128>;
  buyQuote: ({
    payment
  }: {
    payment: Uint128;
  }) => Promise<QuoteResponse>;
  sellQuote: ({
    payment
  }: {
    payment: Uint128;
  }) => Promise<QuoteResponse>;
  phase: () => Promise<CommonsPhase>;
  phaseConfig: () => Promise<CommonsPhaseConfigResponse>;
  tokenContract: () => Promise<Addr>;
  supplyDenom: () => Promise<String>;
  dumpState: () => Promise<DumpStateResponse>;
  ownership: () => Promise<OwnershipForString>;
}
export class CwAbcQueryClient implements CwAbcReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.curveInfo = this.curveInfo.bind(this);
    this.curveType = this.curveType.bind(this);
    this.denom = this.denom.bind(this);
    this.donations = this.donations.bind(this);
    this.isPaused = this.isPaused.bind(this);
    this.fundingPoolForwarding = this.fundingPoolForwarding.bind(this);
    this.hatchers = this.hatchers.bind(this);
    this.hatcher = this.hatcher.bind(this);
    this.hatcherAllowlist = this.hatcherAllowlist.bind(this);
    this.maxSupply = this.maxSupply.bind(this);
    this.buyQuote = this.buyQuote.bind(this);
    this.sellQuote = this.sellQuote.bind(this);
    this.phase = this.phase.bind(this);
    this.phaseConfig = this.phaseConfig.bind(this);
    this.tokenContract = this.tokenContract.bind(this);
    this.supplyDenom = this.supplyDenom.bind(this);
    this.dumpState = this.dumpState.bind(this);
    this.ownership = this.ownership.bind(this);
  }
  curveInfo = async (): Promise<CurveInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      curve_info: {}
    });
  };
  curveType = async (): Promise<CurveType> => {
    return this.client.queryContractSmart(this.contractAddress, {
      curve_type: {}
    });
  };
  denom = async (): Promise<DenomResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      denom: {}
    });
  };
  donations = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<DonationsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      donations: {
        limit,
        start_after: startAfter
      }
    });
  };
  isPaused = async (): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_paused: {}
    });
  };
  fundingPoolForwarding = async (): Promise<NullableAddr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      funding_pool_forwarding: {}
    });
  };
  hatchers = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<HatchersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      hatchers: {
        limit,
        start_after: startAfter
      }
    });
  };
  hatcher = async ({
    addr
  }: {
    addr: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      hatcher: {
        addr
      }
    });
  };
  hatcherAllowlist = async ({
    configType,
    limit,
    startAfter
  }: {
    configType?: HatcherAllowlistConfigType;
    limit?: number;
    startAfter?: string;
  }): Promise<HatcherAllowlistResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      hatcher_allowlist: {
        config_type: configType,
        limit,
        start_after: startAfter
      }
    });
  };
  maxSupply = async (): Promise<NullableUint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      max_supply: {}
    });
  };
  buyQuote = async ({
    payment
  }: {
    payment: Uint128;
  }): Promise<QuoteResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      buy_quote: {
        payment
      }
    });
  };
  sellQuote = async ({
    payment
  }: {
    payment: Uint128;
  }): Promise<QuoteResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      sell_quote: {
        payment
      }
    });
  };
  phase = async (): Promise<CommonsPhase> => {
    return this.client.queryContractSmart(this.contractAddress, {
      phase: {}
    });
  };
  phaseConfig = async (): Promise<CommonsPhaseConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      phase_config: {}
    });
  };
  tokenContract = async (): Promise<Addr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      token_contract: {}
    });
  };
  supplyDenom = async (): Promise<String> => {
    return this.client.queryContractSmart(this.contractAddress, {
      supply_denom: {}
    });
  };
  dumpState = async (): Promise<DumpStateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      dump_state: {}
    });
  };
  ownership = async (): Promise<OwnershipForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ownership: {}
    });
  };
}
export interface CwAbcInterface extends CwAbcReadOnlyInterface {
  contractAddress: string;
  sender: string;
  buy: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  sell: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  donate: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdraw: ({
    amount
  }: {
    amount?: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateMaxSupply: ({
    maxSupply
  }: {
    maxSupply?: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateCurve: ({
    curveType
  }: {
    curveType: CurveType;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateHatchAllowlist: ({
    toAdd,
    toRemove
  }: {
    toAdd: HatcherAllowlistEntryMsg[];
    toRemove: string[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  togglePause: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateFundingPoolForwarding: ({
    address
  }: {
    address?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updatePhaseConfig: (updatePhaseConfigMsg: UpdatePhaseConfigMsg, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  close: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateOwnership: (action: Action, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class CwAbcClient extends CwAbcQueryClient implements CwAbcInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.buy = this.buy.bind(this);
    this.sell = this.sell.bind(this);
    this.donate = this.donate.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.updateMaxSupply = this.updateMaxSupply.bind(this);
    this.updateCurve = this.updateCurve.bind(this);
    this.updateHatchAllowlist = this.updateHatchAllowlist.bind(this);
    this.togglePause = this.togglePause.bind(this);
    this.updateFundingPoolForwarding = this.updateFundingPoolForwarding.bind(this);
    this.updatePhaseConfig = this.updatePhaseConfig.bind(this);
    this.close = this.close.bind(this);
    this.updateOwnership = this.updateOwnership.bind(this);
  }
  buy = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      buy: {}
    }, fee, memo, _funds);
  };
  sell = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      sell: {}
    }, fee, memo, _funds);
  };
  donate = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      donate: {}
    }, fee, memo, _funds);
  };
  withdraw = async ({
    amount
  }: {
    amount?: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw: {
        amount
      }
    }, fee, memo, _funds);
  };
  updateMaxSupply = async ({
    maxSupply
  }: {
    maxSupply?: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_max_supply: {
        max_supply: maxSupply
      }
    }, fee, memo, _funds);
  };
  updateCurve = async ({
    curveType
  }: {
    curveType: CurveType;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_curve: {
        curve_type: curveType
      }
    }, fee, memo, _funds);
  };
  updateHatchAllowlist = async ({
    toAdd,
    toRemove
  }: {
    toAdd: HatcherAllowlistEntryMsg[];
    toRemove: string[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_hatch_allowlist: {
        to_add: toAdd,
        to_remove: toRemove
      }
    }, fee, memo, _funds);
  };
  togglePause = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      toggle_pause: {}
    }, fee, memo, _funds);
  };
  updateFundingPoolForwarding = async ({
    address
  }: {
    address?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_funding_pool_forwarding: {
        address
      }
    }, fee, memo, _funds);
  };
  updatePhaseConfig = async (updatePhaseConfigMsg: UpdatePhaseConfigMsg, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_phase_config: updatePhaseConfigMsg
    }, fee, memo, _funds);
  };
  close = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      close: {}
    }, fee, memo, _funds);
  };
  updateOwnership = async (action: Action, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_ownership: action
    }, fee, memo, _funds);
  };
}